#!/usr/bin/env python
#
#
# Copyright (c) 2009-2015 Caltech. All rights reserved.
# Written by Seung Woo Shin (seungwoo.theory@gmail.com)
#
#
# Verifier_condense executable.
#

import sys, compiler, crn_parser, dom_parser, random, os, crn_bisimulation_equivalence, crn_pathway_equivalence, string, copy, enumerator.input as enumerator_in, enumerator.output as enumerator_out

def find(l, key):
    for i in range(len(l)):
        if l[i] == key:
            return i
    return None

def rotate(complex):
    def hardcopyList(l):
        if type(l) != list:
            return l
        return map(hardcopyList, l)

    complex = hardcopyList(complex)

    if "+" not in complex[0]:
        return complex        
    else:
        p = find(complex[0], "+")
        dom = complex[0][p + 1:] + ["+"] + complex[0][:p]

        # change parentheses appropriately
        dpr = complex[1]
        stack = []
        for i in range(p):
            if dpr[i] == "(": stack.append(i)
            elif dpr[i] == ")": stack.pop()
        for i in stack:
            dpr[i] = ")"
        stack = []
        for i in reversed(range(p + 1, len(dpr))):
            if dpr[i] == ")": stack.append(i)
            elif dpr[i] == "(": stack.pop()
        for i in stack:
            dpr[i] = "("
        
        dpr = dpr[p + 1:] + ["+"] + dpr[:p]
        return [dom, dpr]

def patternMatch(x, y):
    if "+" in x[0]:
        if "+" not in y[0]:
            return False
        px = find(x[0], "+")
        py = find(y[0], "+")
        return patternMatch([x[0][:px], x[1][:px]],
                            [y[0][:py], y[1][:py]]) and \
               patternMatch([x[0][px + 1:], x[1][px + 1:]],
                            [y[0][py + 1:], y[1][py + 1:]])

    if len(x[0]) == 0:
        if len(y[0]) > 0:
            return False
        else:
            return True

    if x[0][0] != "?":
        if len(y[0]) == 0 or x[0][0] != y[0][0] or x[1][0] != y[1][0]:
            return False
        else:
            return patternMatch([x[0][1:], x[1][1:]],
                                [y[0][1:], y[1][1:]])
    else:
        for i in range(len(y) + 1):
            if patternMatch([x[0][1:], x[1][1:]],
                            [y[0][i:], y[1][i:]]):
                return True
        return False

def removeFuels(crn, fuel):
    crn = [[filter(lambda s: s not in fuel, rxn[0]),
            filter(lambda s: s not in fuel, rxn[1])]
           for rxn in crn]
    return crn

def remove_duplicates(l):
    r = []
    if len(l) == 0: return []
    l.sort()
    while len(l) > 1:
        if l[0] != l[1]:
            r.append(l[0])
        l = l[1:]
    r.append(l[0])
    return r

def test_condense(domfile, method, verbose = True):
    # Parse the dom
    tfile = "".join(random.sample(string.letters + string.digits, 8)) + "._tmp"
    dom = dom_parser.parse(domfile)

    # Generate an input file for state enumerator
    F = open(tfile, "w")
    if len(dom) == 2:   # there is sequence information
        complexes = dom[1]
        for i in dom[0]:
            print >> F, "domain", i[0], ":", i[1]
    else:
        complexes = dom[0]

    strand_n = 0
    out_strands = {}
    out_complexes = []

    for i in complexes:
        c = [i[0],"",""]
        s = ""
        i[1].append("+")
        for j in i[1]:
            if j == "?": continue
            if type(j) == list:
                if len(j) == 2:
                    j = j[0] + j[1]
                else:
                    j = j[0]
                s += " " + j
            elif j == "+":
                if s not in out_strands.keys():
                    strand_n += 1
                    sname = "strand"+str(strand_n)
                    out_strands[s] = sname
                else:
                    sname = out_strands[s]
                s = ""
                c[1] += " "+sname
        i[1] = i[1][:-1]
        for j in i[2]:
            if j == "?": continue
            if j == "+": j = " + "
            c[2] += j
        out_complexes.append(c)

    for s in out_strands.keys():
        sname = out_strands[s]
        print >> F, "strand", sname, ":", s

    for [c0,c1,c2] in out_complexes:
        print >> F, "complex", c0, ":"
        print >> F, c1
        print >> F, c2
        print >> F
    F.close()

    #
    # call state enumerator
    #
    enumerator = enumerator_in.input_enum(tfile)
    enumerator.MAX_COMPLEX_COUNT = 10000
    enumerator.MAX_REACTION_COUNT = 10000
    enumerator.MAX_COMPLEX_SIZE = 100
    enumerator.enumerate()
    enumerator_out.output_crn(enumerator,tfile, output_condensed = True)
    F = open(tfile, "r")
    old_crn = []
    for line in F:
        line = line.split("->")
        line[0] = line[0].split("+")
        line[1] = line[1].split("+")
        line[0] = map(lambda x: x.strip(), line[0])
        line[1] = map(lambda x: x.strip(), line[1])
        line[0] = sorted(line[0])
        line[1] = sorted(line[1])
        old_crn.append(line)
    F.close()
    enumerator_out.output_crn(enumerator,tfile, output_condensed = False)
    F = open(tfile, "r")
    new_crn = []
    for line in F:
        line = line.split("->")
        line[0] = line[0].split("+")
        line[1] = line[1].split("+")
        line[0] = map(lambda x: x.strip(), line[0])
        line[1] = map(lambda x: x.strip(), line[1])
        line[0] = sorted(line[0])
        line[1] = sorted(line[1])
        new_crn.append(line)
    F.close()
    # delete the temporary file
    filelist = [ f for f in os.listdir(".") if f.endswith("._tmp") ]
    for f in filelist:
        os.remove(f)

    fs = set()
    fsp = set()
    inter = {}
    for x in enumerator.resting_states:
        y = str(x)
        fs.add(y)
        for z in x.complexes:
            z = str(z)
            fsp.add(z)
            inter[z] = [y]

    # fs = formal species; cs = fuels or constant species
    if method == "--bisimulation":
        return crn_bisimulation_equivalence.test((old_crn, fs), (new_crn, fs), verbose)#, inter)
    elif method == "--pathway":
        return crn_pathway_equivalence.test((old_crn, fs), (new_crn, fsp), inter, verbose)


if __name__ == "__main__":
    # The name of the program
    program_name = "verify_condense"

    # Help message
    if "--help" in sys.argv:
        print "Usage: " + program_name + " DOMFILE [OPTION]"
        print "    or " + program_name + " TSFILE CRNFILE [OPTION]"
        print "Verify the equivalence between detailed semantics and condensed semantics for"
        print "DOMFILE or for CRNFILE compiled using TSFILE."
        print
        print "  --pathway      Use the pathway equivalence notion [default]."
        print "  --bisimulation Use the bisimulation equivalence notion."
        print "  --help         Output this help."
        print
        print "Report bugs to <seungwoo.theory@gmail.com>."
        exit()

    # Did I get a sufficient number of arguments?
    if len(sys.argv) < 2: # expects at least one arguments
        print program_name + ": missing operand after `" + program_name + "'"
        print program_name + ": try `" + program_name + " --help' for more information."
        exit()

    # Get the arguments.
    if len(sys.argv) == 2:
        dom_file = sys.argv[1]
        method = "--pathway"
    elif len(sys.argv) == 3:
        if sys.argv[2][0] == '-':
            dom_file = sys.argv[1]
            method = sys.argv[2]
        else:
            ts_file = sys.argv[1]
            crn_file = sys.argv[2]
            method = "--pathway"
    else:
        ts_file = sys.argv[1]
        crn_file = sys.argv[2]
        method = sys.argv[3]

    try:
        dom_file
    except NameError:
        # Add the correct extensions if necessary.
        if len(ts_file) < 3 or ts_file[-3:] != ".ts": ts_file += ".ts"
        if len(crn_file) < 4 or crn_file[-4:] != ".crn": crn_file += ".crn"
        compiler.compile(ts_file, crn_file)
        dom_file = crn_file[:-4] + ".dom"

    # Add the correct extensions if necessary.
    if len(dom_file) < 4 or dom_file[-4:] != ".dom": dom_file += ".dom"

    v = test_condense(dom_file, method, True)

    if v:
        print "verify: compilation was correct."
    else:
        print "verify: compilation was incorrect."
