#!/usr/bin/env python

import os
import sys
import argparse
import pkg_resources

#'http://www.github.com/bad-ants-fleet/crnsimulator'
from crnsimulator import ReactionGraph

from nuskell import translate, verify, printCRN, __version__
from nuskell.parser import parse_crn_string, split_reversible_reactions
from nuskell.objects import TestTube, TestTubeIO 
from nuskell.enumeration import TestTubePeppercornIO
from nuskell.verifier import removeSpecies, modular_bisimulation

def get_peppercorn_args(parser):
  """Selected arguments for the peppercorn interface. """
  peppercorn = parser.add_argument_group('Peppercorn Reaction Enumerator Arguments')
  peppercorn.add_argument('--max-complex-size', default=100, type=int,
      dest='MAX_COMPLEX_SIZE', metavar='<int>', 
      help="""Maximum number of strands allowed in a complex (used to prevent
      polymerization)""")
  peppercorn.add_argument('--max-complex-count', default=1000, type=int,
      dest='MAX_COMPLEX_COUNT', metavar='<int>',
      help="""Maximum number of complexes that may be enumerated before the enumerator halts.""")
  peppercorn.add_argument('--max-reaction-count', default=10000, type=int,
      dest='MAX_REACTION_COUNT', metavar='<int>',
      help="""Maximum number of reactions that may be enumerated before the
      enumerator halts.""")

  peppercorn.add_argument('--reject-remote', action='store_true', dest='REJECT_REMOTE',
      help="Discard remote toehold mediated 3-way and 4-way branch migration reactions.")
  peppercorn.add_argument('--ignore-branch-3way', action='store_true',
      help="Ignore 3-way branch migration events during enumeration.")
  peppercorn.add_argument('--ignore-branch-4way', action='store_true',
      help="Ignore 4-way branch migration events during enumeration.")

  # TODO: explain these options in more deatail!
  peppercorn.add_argument('--release-cutoff-1-1', type=int, default=6, dest='RELEASE_CUTOFF_1_1',
      metavar='<int>', 
      help="""Maximum number of bases that will be released spontaneously in a
      1-1 `open` reaction""")
  peppercorn.add_argument('--release-cutoff-1-n', type=int, default=6, dest='RELEASE_CUTOFF_1_N',
      metavar='<int>',
      help="""Maximum number of bases that will be released spontaneously in a
      1-n `open` reaction.""")
  peppercorn.add_argument('--release-cutoff', type=int, default=None, dest='RELEASE_CUTOFF',
      metavar='<int>',
      help="""Maximum number of bases that will be released spontaneously in an
      `open` reaction, for either 1-1 or 1-n reactions (equivalent to setting
      --release-cutoff-1-1 and --release-cutoff-1-n to the same value)""")

  peppercorn.add_argument('--no-max-helix', action='store_true',
      help="""Do not apply 'max helix at a time' semantics to 3-way branch
      migration reactions.""")

  peppercorn.add_argument('--legacy-unzip', action='store_true', dest='LEGACY_UNZIP',
      help="""Apply legacy 'UNZIP=True' behavior. Note: --legacy-unzip will
      have no effect, if max helix semantics are disabled (--no-max-helix)""")

  # NOTE: Output formatting: this option is not directly passed on to peppercorn
  peppercorn.add_argument('--enum-detailed', action='store_true',
      help="Do not condense reactions into only resting complexes")

  # NOTE: The option --no-rates was removed, because peppercorn always computes
  # rates, but you may choose to ignore them for condensed reaction graphs. 
  # k-fast enables to prune the condensed network, leaving the default of 0 M/s, has
  # the same effect.

  peppercorn.add_argument('--k-slow', default=0.0, type=float, metavar='<flt>',
      help="Unimolecular reactions slower than this rate will be discarded")

  peppercorn.add_argument('--k-fast', default=0.0, type=float, metavar='<flt>',
      help="Unimolecular reactions slower than this rate will be marked as slow")

  return parser

def get_nuskell_args(parser) :
  """ A collection of arguments for Nuskell """
  #input = parser.add_mutually_exclusive_group(required=True)
  input = parser.add_argument_group('Nuskell Input (required)')
  default = parser.add_argument_group('Nuskell Output')
  verify = parser.add_argument_group('Nuskell Verification')
  simulate = parser.add_argument_group('Nuskell Simulation')

  parser.add_argument('--version', action='version', version='%(prog)s ' + __version__)
  parser.add_argument("-v", "--verbose", action='count', default=0,
      help="print verbose output. -vv increases verbosity level.")


  # Options for the translation mode of Nuskell
  input.add_argument("--ts", action = 'store', metavar='</path/to/file>',
      help="""Specify a translation scheme. Either choose from the default
      schemes which are installed with Nuskell, or specify the full path to a
      not-installed scheme. Omitting both --ts and --readpil will print a list
      of available schemes and exit.""")

  input.add_argument("--readpil", action = 'store', metavar='</path/to/file>',
      help="""Read a compiled CRN from a file in PIL format (kernel-notation).
      Use this option as an alternative to --ts.""")

  default.add_argument("-o", "--output", default='domainlevel', action = 'store', 
      metavar='<str>', help="Specify basename of output files.")

  default.add_argument("--pilfile", action = 'store_true',
      help="""Print results in the Pepper Internal Language *.PIL file format
      (kernel notation).""")

  default.add_argument("--dnafile", action = 'store_true',
      help="Print results in the VisualDSD *.DNA file format.")

  default.add_argument("--enumerate", action = 'store_true',
      help="""Enumerate the implementation CRN. This is turned on automatically
      when using the arguments --verify or --simulate.""")

  default.add_argument("--simulate", action = 'store_true',
      help="""Print Python executables to simulate the formal and/or
      implementation CRNs using ODEs.""")

  default.add_argument("-u", "--concentration-unit", default='M', action = 'store', 
      choices=('M', 'mM', 'uM', 'nM', 'pM'),
      help="""Specify default units. They are used when writing concentrations
      to files, when calculating reaction rates, and when using the option
      --simulate""")

  # Choose a verification method.
  verify.add_argument("--verify", nargs='+', default='', action = 'store', 
      choices=('bisimulation', 'pathway', 'integrated', 'modular-bisimulation',
      'bisim-loop-search', 'bisim-depth-first', 'bisim-whole-graph',
      'modular-bisim-loop-search',
      'modular-bisim-depth-first', 
      'modular-bisim-whole-graph'), 
      metavar='<str>', help="""Specify verification methods. Choose one or more
      from: bisimulation, pathway, integrated, modular-bisimulation,
      bisim-loop-search, bisim-depth-first, bisim-whole-graph,
      modular-bisim-loop-search,
      modular-bisim-depth-first, 
      modular-bisim-whole-graph.""") 

  verify.add_argument("--modular", action='store_true',
      help="""After enumeration of the full system, enumerate individual CRN
      modules separately, to identify crosstalk between reactions. This is
      turned on automatically when using modular-bisimulation verification.""")

  verify.add_argument("--verify-timeout", type=int, default=30, metavar='<int>',
      help="Specify time in seconds to wait for verification to complete.")

  return parser

def main() :
  """ The Nuskell compiler.  
  
    - translate formal CRNs into domain-level strand displacement systems.
    - verify the equivalence between formal CRN and implementation CRN.

  Output:
    - Domain-level DSD circuits printed into .pil and/or .dna files
    - Verbose information to STDOUT
    - verification results
    - simulatior scripts
  """
  parser = argparse.ArgumentParser(
      formatter_class=argparse.ArgumentDefaultsHelpFormatter)
  parser = get_nuskell_args(parser)
  parser = get_peppercorn_args(parser)
  args = parser.parse_args()

  # ~~~~~~~~~~~~~~~~~~~
  # Argument processing
  # ~~~~~~~~~~~~~~~~~~~
  args.UNZIP = not args.no_max_helix
  pilfile = args.output + '_tl.pil' if args.pilfile else None
  dnafile = args.output + '_tl.dna' if args.dnafile else None

  if not args.modular:
    args.modular = any(map(lambda x: 'modular' in x, args.verify))

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Parse and process input CRN 
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  input_crn = sys.stdin.readlines()
  input_crn = "".join(input_crn)
  fcrn, fs, signals, fuels = parse_crn_string(input_crn) 

  if args.verbose:
    print "formal species: {}; signal species: {}; fuel species: {}".format(
        sorted(fs), sorted(signals), sorted(fuels))

  if not (set(fs) <= set(signals)):
    # If this is not caught here, it will assign fs as fuels...
    raise Warning('all formal species {} should also be signals {}'.format(
      fs, signals))

  # ~~~~~~~~~~~~~~~~~~~~~~~
  # Initialize the TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~
  if args.ts : # Translate CRN using a translation scheme
    print "\nTranslating..."
    assert fs == signals
    solution, modules = translate(input_crn, args.ts, 
        modular = args.modular,
        verbose = (args.verbose > 1)) 
  elif args.readpil : # Parse implementation species from a PIL file
    print "Parsing PIL file..."
    solution = TestTube()
    TestTubeIO(solution).load_pil_kernel(args.readpil)
  else :
    # At some point Nuskell should choose translation schemes automatically, 
    # but we are not there yet ... use nuskellCMP for such things.
    print "Please specify a translation scheme, see option --ts. For example:"
    schemedir = pkg_resources.resource_filename('nuskell', 'schemes')
    print 'Schemes in:', schemedir
    for s in os.listdir(schemedir) :
      print " --ts {}".format(s) 
    raise SystemExit

  if args.verbose :
    print "Complexes in Solution: "
    for cplx in sorted(solution.complexes, key=lambda x : str(x)):
      print ' ', cplx.name, '=', cplx.kernel

  if dnafile:
    with open(dnafile, 'w') as dna:
      TestTubeIO(solution).write_dnafile(dna, signals=signals, 
          crn=fcrn, ts = args.ts if args.ts else None)
  if pilfile:
    with open(pilfile, 'w') as pil:
      TestTubeIO(solution).write_pil_kernel(pil, unit=args.concentration_unit, 
          crn=fcrn, ts = args.ts if args.ts else None)

  if pilfile or dnafile :
    print "Wrote file(s):",
    if pilfile: print pilfile,
    if dnafile: print dnafile,
    print

  # NOTE: if we already know names for signals and fuels, extract them,
  # otherwise they are defined as follows:
  # signals = species that correspond to formal species in the formal CRN
  # fuels   = all non-signal species that have concentration > 0 nM
  if fuels :
    fuels = solution.selected_complexes(fuels)
  else :
    fuels = solution.present_complexes(exclude=signals)
  signals = solution.selected_complexes(signals)

  #if fuels == []:
  #  raise ValueError('solution does not contain fuels')
  if signals == []:
    raise SystemExit('EXIT: solution does not contain signals.')

  if args.verbose:
    print "formal species: {}; signal species: {}; fuel species: {}".format(
        sorted(fs), sorted(map(str, signals)), sorted(map(str, fuels)))

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Prepare enumerated CRN and TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if args.verify or args.simulate or args.enumerate :
    print "\nEnumerating reaction pathways..."
    condensed = not args.enum_detailed
    solution.enumerate_reactions(args, condensed = condensed, prefix='e', rename=100)

    if args.verbose > 1 : # print the enumerated CRN
      for r in solution.reactions:
        print r, "[{} {} - {}]".format(r.rate, r.rateunits, r.rtype)

    print "\nReplacing regular-expression complexes ..."
    interpret = solution.interpret_species(fs, prune=True)
    # NOTE: Some scheme use history domains within constant and intermediate
    # species, these will not get replaced.

    # Return the implementation CRN. ( = enumerated CRN without regex complexes)
    icrn = []
    for r in solution.reactions:
      if args.verbose:
        print r, "[{} {} - {}]".format(r.rate, r.rateunits, r.rtype)
      rxn = [map(str,r.reactants),map(str,r.products), [r.rate]]
      icrn.append(rxn)

    print "Enumerated system: {} species, {} reactions".format(len(solution.complexes), len(icrn))
    print "  - {} signal species".format(
        len([c for c in solution.complexes if c.name in interpret.keys()]))
    print "  - {} fuel species".format(
        len([c for c in solution.complexes if c.name in map(str, fuels)]))
    print "  - {} intermediate species".format(
        len([c for c in solution.complexes if c.name not in (interpret.keys() + map(str,fuels))]))
    print 'Number of distinct strands in the system:', len(solution.strands)
    print 'Length of all distinct strands in the system:', sum(sum(
      map(lambda d: d.length, s)) for s in solution.strands.values())

    if args.simulate or args.pilfile :
      # If you use translation schemes, or if you didn't specify concentrations in
      # the PIL file, then all non-signal species have 'infinite' concentration at
      # this point. The experimental concentrations can be set by printing a
      # pilfile, adjusting it, and loading it instead of the translation scheme.

      # Set *initial* concentration of fuels to 100 nM. 
      for f in fuels:
        if None in solution.get_complex_concentration(f):
          solution.set_complex_concentration(f, 100e-9, False)

      # Set *initial* concentraiton of signals to 0 nM.
      for f in solution.selected_complexes(names=interpret.keys()):
        if None in solution.get_complex_concentration(f):
          solution.set_complex_concentration(f, 0, False)

      # Set *initial* concentraiton of remaining species (intermediates) to 0 nM.
      for i in solution.complexes:
        if None in solution.get_complex_concentration(i):
          solution.set_complex_concentration(i, 0, False)

      if args.pilfile :
        pilfile = args.output + '_c0.pil' 
        with open(pilfile, 'w') as pil:
          TestTubeIO(solution).write_pil_kernel(pil, unit=args.concentration_unit,
              crn=fcrn, ts = args.ts if args.ts else None)

    if args.modular :
      # TODO(SB): cross-check verification: 
      # - enumeration detects crosstalk between modules and append it as
      #   the last iCRN which has no corresponding fCRN.
      seen_intermed = set()
      intermediates = filter(lambda x: x.name[0] == 'e', solution.complexes)
      module_crns = []
      for e, module in enumerate(modules) :
        # first, replace history complexes with their interpretation!
        for cplx in module.complexes:
          # TODO quite inefficient loops
          for k, v in interpret.items():
            if (cplx.name in v) and k != cplx.name :
              [newc] = solution.selected_complexes([k])
              module.add_complex(newc, solution.get_complex_concentration(newc))
              if module.has_complex(cplx):
                module.rm_complex(cplx)

        # then, enumerate!
        module.enumerate_reactions(args, condensed = condensed, prefix='tmp')

        # after enumeration, rename all tmp species with e species names in solution.
        for cplx in module.complexes:
          if cplx.name[:3] == 'tmp':
            replaced = False
            debugging = 0
            # TODO also quite inefficient
            while (not replaced):
              for x in intermediates:
                if (cplx.sequence, cplx.structure) == (x.sequence, x.structure):
                  cplx.name = x.name
                  seen_intermed.add(x)
                  replaced = True
                  break
              cplx.rotate_once
              if debugging > len(cplx.lol_sequence):
                raise RuntimeError("couldn't find enumerated species")
              debugging += 1

        # append the CRN 
        mcrn = []
        for r in module.reactions:
          if args.verbose :
            print r, "[{} {} - {}]".format(r.rate, r.rateunits, r.rtype)
          rxn = [map(str,r.reactants),map(str,r.products), [r.rate]]
          mcrn.append(rxn)
        module_crns.append(mcrn)

      # last, identify crosstalk as the last implementation CRN (without formal correspondence)
      crosstalk = set()
      for x in intermediates :
        if x not in seen_intermed :
          RG = solution.ReactionGraph
          for react in RG.successors(x) + RG.predecessors(x):
            crosstalk.add(react)

      # append the CRN 
      mcrn = []
      for r in crosstalk :
        if args.verbose :
          print r, "[{} {} - {}]".format(r.rate, r.rateunits, r.rtype)
        rxn = [map(str,r.reactants),map(str,r.products), [r.rate]]
        mcrn.append(rxn)
      if mcrn: module_crns.append(mcrn)

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Verify equivalence of CRNs
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~
  mcrn = map(lambda x: split_reversible_reactions([x]), fcrn)
  fcrn = split_reversible_reactions(fcrn)
  if args.verify :
    print "\nVerification using:", args.verify

    # NOTE: implicitly also removes rate constants
    vcrn = removeSpecies(icrn, map(str, fuels))
    if args.verbose :
      print "Verification CRN:"
      printCRN(vcrn, reversible = True, rates=False)

    if args.modular :
      icrns = map(lambda x: removeSpecies(x, map(str,fuels)), module_crns)
      if args.verbose :
        for e, m in enumerate(icrns):
          print "CRN Module {}:".format(e+1)
          if e < len(mcrn):
            printCRN(mcrn[e], reversible = True, rates=False)
          else :
            print "CROSSTALK:"
          print "--"
          printCRN(m, reversible = True, rates=False)

    if interpret and args.verbose :
      print "Partial interpretation:"
      for impl, formal in sorted(interpret.items()) :
        print "  {} => {}".format(impl, ', '.join([x for x in formal.elements()]))

    for meth in args.verify :
      if 'modular-' in meth:
        # NOTE: Temporary to fixe a bug in testModules
        import copy
        backup = copy.deepcopy(interpret) if interpret else None
        v, i = modular_bisimulation(mcrn, icrns, fs, interpret=backup, method=meth[8:],
            verbose=(args.verbose>1), timeout=args.verify_timeout)
      else :
        v, i = verify(fcrn, vcrn, fs, interpret=interpret, method=meth,
            verbose=(args.verbose>1), timeout=args.verify_timeout)

      if i and args.verbose :
        if not v : i = i[2 if args.modular else 0]
        print "Returned interpretation ['{}']:".format(meth)
        for impl, formal in sorted(i.items()) :
          print "  {} => {}".format(impl, ', '.join([x for x in formal.elements()]))

      if v is True:
        print " {}: CRNs are {} equivalent.".format(v, meth)
      elif v is False:
        print " {}: CRNs are not {} equivalent.".format(v, meth)
      elif v is None:
        print " {}: {} verification did not terminate within {} seconds.".format(v, 
            meth, args.verify_timeout)

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Simulate CRNs in a TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if args.simulate :
    print "\nWriting executable simulator scripts: {}_fCRN.py {}_iCRN.py".format(
        args.output, args.output)

    # Change CRN format from [[r], [p], [None]], if needed and add rate 1 to every reaction.
    scrn = map(lambda rxn: rxn[:2] + (rxn[2] if rxn[2] != [None] else [1]), fcrn)

    # Simulate the formal CRN using crnsimulator
    CRG = ReactionGraph(scrn)
    fFile, _ = CRG.write_ODE_lib(sorted(CRG.species), filename = args.output+'_fCRN')
    if args.verbose :
      print 'Wrote formal CRN simulator:', fFile 
      print ' - execute with: python {}'.format(fFile)

    # Simulate the interpretation CRN using crnsimulator
    iFile, _ = solution.simulate_crn(args.output + '_iCRN', unit=args.concentration_unit)
    if args.verbose :
      print 'Wrote implementation CRN simulator:', iFile
      print ' - execute with: python {}'.format(iFile)

if __name__ == '__main__':
  main()

