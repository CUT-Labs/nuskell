#!/usr/bin/env python
from __future__ import absolute_import, division, print_function

import os
import sys
import logging
import argparse
import pkg_resources

from dsdobjects.utils import natural_sort

from nuskell import translate, verify, __version__
from nuskell.objects import TestTube, TestTubeIO
from nuskell.crnutils import parse_crn_string, Reaction
from nuskell.crnutils import split_reversible_reactions, removeSpecies, genCRN, genCON
from nuskell.verifier import modular_bisimulation

class colors:
    RED = '\033[91m'
    YELLOW = '\033[93m'
    GREEN = '\033[92m'
    BLUE = '\033[94m'
    PINK = '\033[95m'
    CYAN = '\033[96m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    colors = [RED, YELLOW, GREEN, CYAN, BLUE, PINK]

    @staticmethod
    def color(string):
        pass

    @staticmethod
    def legend(keys=None):
        if keys is None:
            l = enumerate(colors.colors)
        else:
            l = zip(keys, colors.colors)
        return "\n".join([(c + str(i) + colors.ENDC) for i, c in l])

class ColorFormatter(logging.Formatter):
    def __init__(self, msg, use_color=True):
        logging.Formatter.__init__(self, msg)
        self.use_color = use_color
        self.COLORS = {
            'DEBUG': colors.CYAN,
            'INFO': colors.BLUE,
            'WARNING': colors.YELLOW,
            'ERROR': colors.RED,
            'Exception': colors.PINK,
        }
        self.RESET = colors.ENDC

    def format(self, record):
        levelname = record.levelname
        if self.use_color:
            record.levelname = self.COLORS[levelname] + \
                levelname + self.RESET

        return super(ColorFormatter, self).format(record)

def get_peppercorn_args(parser):
    """Selected arguments for the peppercorn interface. """
    peppercorn = parser.add_argument_group(
        'Peppercorn Reaction Enumerator Arguments')
    peppercorn.add_argument('--max-complex-size', default=50, type=int, metavar='<int>',
                            help="""Maximum number of strands allowed in a complex (used to prevent
      polymerization)""")
    peppercorn.add_argument('--max-complex-count', default=1000, type=int, metavar='<int>',
                            help="""Maximum number of complexes that may be enumerated before the enumerator halts.""")
    peppercorn.add_argument('--max-reaction-count', default=10000, type=int, metavar='<int>',
                            help="""Maximum number of reactions that may be enumerated before the
      enumerator halts.""")

    peppercorn.add_argument('--reject-remote', action='store_true',
                            help="Discard remote toehold mediated 3-way and 4-way branch migration reactions.")
    peppercorn.add_argument('--ignore-branch-3way', action='store_true',
                            help="Ignore 3-way branch migration events during enumeration.")
    peppercorn.add_argument('--ignore-branch-4way', action='store_true',
                            help="Ignore 4-way branch migration events during enumeration.")

    # TODO: explain these options in more detail!
    peppercorn.add_argument('--release-cutoff-1-1', type=int, default=6,
                            metavar='<int>',
                            help="""Maximum number of bases that will be released spontaneously in a
      1-1 `open` reaction""")
    peppercorn.add_argument('--release-cutoff-1-n', type=int, default=6,
                            metavar='<int>',
                            help="""Maximum number of bases that will be released spontaneously in a
      1-n `open` reaction.""")
    peppercorn.add_argument('--release-cutoff', type=int, default=None,
                            metavar='<int>',
                            help="""Maximum number of bases that will be released spontaneously in an
      `open` reaction, for either 1-1 or 1-n reactions (equivalent to setting
      --release-cutoff-1-1 and --release-cutoff-1-n to the same value)""")

    peppercorn.add_argument('--no-max-helix', action='store_true',
                            help="""Do not apply 'max helix at a time' semantics to 3-way branch
      migration reactions.""")

    # NOTE: Output formatting: this option is not directly passed on to
    # peppercorn
    peppercorn.add_argument('--enum-detailed', action='store_true',
                            help="Do not condense reactions into only resting complexes")

    # NOTE: The option --no-rates was removed, because peppercorn always computes
    # rates, but you may choose to ignore them for condensed reaction graphs.
    # k-fast enables to prune the condensed network, leaving the default of 0 M/s, has
    # the same effect.

    peppercorn.add_argument('--k-slow', default=0.0, type=float, metavar='<flt>',
                            help="Unimolecular reactions slower than this rate will be discarded")

    peppercorn.add_argument('--k-fast', default=0.0, type=float, metavar='<flt>',
                            help="Unimolecular reactions slower than this rate will be marked as slow")

    return parser


def get_nuskell_args(parser):
    """ A collection of arguments for Nuskell """
    #input = parser.add_mutually_exclusive_group(required=True)
    input = parser.add_argument_group('Nuskell Input Arguments (required - choose one)')
    default = parser.add_argument_group('Nuskell Output Arguments')
    verify = parser.add_argument_group('Nuskell Verification Arguments')
    simulate = parser.add_argument_group('Nuskell Simulation Arguments')

    parser.add_argument('--version', action='version', version='%(prog)s ' + __version__)
    parser.add_argument("--schemes", action='store_true', 
            help="Print a list of available schemes and exit.")
    parser.add_argument("-v", "--verbose", action='count', default=0,
            help="print verbose output. -vv increases verbosity level.")

    # Options for the translation mode of Nuskell
    input.add_argument("--ts", action='store', metavar='</path/to/file>',
            help="""Specify a translation scheme. Either choose from the
            default schemes which are installed with Nuskell, or specify the
            full path to a not-installed scheme. Omitting both --ts and
            --readpil will print a list of available schemes and exit.""")

    input.add_argument("--readpil", action='store', metavar='</path/to/file>',
            help="""Read a domain-level strand displacement system from a file
            in PIL format. (Modular bisimulation verification is not available
            through this mode.)""")

    input.add_argument("--enumerated-pil", action='store', metavar='</path/to/file>',
            help="""Read a domain-level strand displacement system from a file
            in PIL format. Use this option to provide a custom set of reactions
            and supress built-in reaction enumeration. (Modular bisimulation
            verification is not available through this mode.)""")

    default.add_argument("-o", "--output", default='domainlevel', action='store', metavar='<str>', 
            help="Specify basename of output files.")

    default.add_argument("--pilfile", action='store_true',
            help="""Print (intermediate) results in the Pepper Internal
            Language (*.pil) file format.""")

    default.add_argument("--dnafile", action='store_true',
            help="Print (intermediate) results in the VisualDSD (*.dna) file format.")

    default.add_argument("-u", "--concentration-units", default='M', action='store',
            choices=('M', 'mM', 'uM', 'nM', 'pM'),
            help="""Specify default concentration units when writing results to 
            ouptut files (reaction rates, initial concentrations). """)

    default.add_argument("--enumerate", action='store_true',
            help="""Enumerate the DSD system. This is turned on automatically
            when using the argument --verify in combination with --ts or --readpil.""")

    # Choose a verification method.
    verify.add_argument("--verify", nargs = '+', default = [], action = 'store',
            choices=('bisimulation', 'pathway', 'integrated', 'modular-bisimulation',
                'bisim-loop-search', 'bisim-depth-first', 'bisim-whole-graph',
                'modular-bisim-loop-search', 'modular-bisim-depth-first',
                'modular-bisim-whole-graph'), metavar = '<str>', 
            help="""Specify verification methods. Choose one or more from:
            bisimulation, pathway, integrated, modular-bisimulation,
            bisim-loop-search, bisim-depth-first, bisim-whole-graph,
            modular-bisim-loop-search, modular-bisim-depth-first,
            modular-bisim-whole-graph.""")

    verify.add_argument("--modular", action = 'store_true',
            #help="""After enumeration of the full system, enumerate individual
            #CRN modules separately, to identify crosstalk between reactions.
            #This is turned on automatically when using modular-bisimulation
            #verification.""")
            help = argparse.SUPPRESS)

    verify.add_argument("--verify-timeout", type = int, default = 30, metavar = '<int>',
            help="Specify time in seconds to wait for verification to complete.")

    return parser

def main(args):
    """ The Nuskell compiler.

      - translate formal CRNs into domain-level strand displacement systems.
      - verify the equivalence between formal CRN and implementation CRN.

    Output:
      - Domain-level DSD circuits printed into .pil and/or .dna files
      - Verbose information to STDOUT
      - verification results
      - simulatior scripts
    """
    if args.schemes:
        schemedir = pkg_resources.resource_filename('nuskell', 'schemes')
        print("Listing schemes in: {}".format(schemedir))
        for s in sorted(os.listdir(schemedir)):
            print("   --ts {}".format(s))
        raise SystemExit

    logger = logging.getLogger()
    if args.verbose == 1:
        logger.setLevel(logging.INFO)
    elif args.verbose == 2:
        logger.setLevel(logging.DEBUG)
    elif args.verbose >= 3:
        logger.setLevel(logging.NOTSET)
    ch = logging.StreamHandler()

    formatter = ColorFormatter('%(levelname)s %(message)s', use_color=sys.stdout.isatty())
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    if args.verbose > 3:
        logging.warning("Verbosity greater than -vvv has no effect")

    title = 'Nuskell - nucleic acid strand displacement compiler'
    version = " {} ".format(__version__)
    banner = (colors.BOLD + title + colors.ENDC + \
              colors.GREEN + version + colors.ENDC)
    logging.info(banner)

    # ~~~~~~~~~~~~~~~~~~~
    # Argument processing
    # ~~~~~~~~~~~~~~~~~~~
    comppil = args.output + '_sys.pil' if args.pilfile else None
    enumpil = args.output + '_enum.pil' if args.pilfile else None
    dnafile = args.output + '.dna' if args.dnafile else None

    if not args.modular:
        args.modular = any(map(lambda x: 'modular' in x, args.verify))

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Parse and process input CRN
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    input_crn = sys.stdin.readlines()
    input_crn = "".join(input_crn)
    fcrn, fs = parse_crn_string(input_crn)

    # ~~~~~~~~~~~~~~~~~~~~~~~
    # Initialize the TestTube
    # ~~~~~~~~~~~~~~~~~~~~~~~
    if args.ts:  # Translate CRN using a translation scheme
        logging.info("")
        logging.info(colors.BOLD + "Translating..." + colors.ENDC)
        solution, modules = translate(input_crn, args.ts,
                                      modular = args.modular,
                                      verbose = (args.verbose > 1))
    elif args.readpil:  # Parse information from a PIL file (cannot give modules!)
        logging.info("Parsing PIL file...")
        solution = TestTube()
        TestTubeIO(solution).load_pil(args.readpil, is_file = True)
        # Assign fuel complexes and signal complexes.

        # signals = species that correspond to formal species in the formal CRN
        # fuels   = all non-signal species that have concentration > 0 nM
        for cplx in solution.complexes:
            if cplx.name in fs:
                solution.nodes[cplx]['ctype'] = 'signal'
            elif cplx.concentration is not None:
                solution.nodes[cplx]['ctype'] = 'fuel'
    else:
        # At some point Nuskell should choose translation schemes automatically,
        # but we are not there yet ... use nuskellCMP for such things.
        logging.error("Please specify a translation scheme, see option --ts.")
        schemedir = pkg_resources.resource_filename('nuskell', 'schemes')
        logging.error("For exaple the schemes in: {}".format(schemedir))
        for s in sorted(os.listdir(schemedir)):
            print("   --ts {}".format(s))
        raise SystemExit

    fuels = solution.fuel_complexes
    signals = solution.signal_complexes

    if args.ts and solution.unspecified_complexes != []:
        raise SystemExit('EXIT: solution contains intermediate species.')

    if signals == []:
        raise SystemExit('EXIT: solution does not contain signals.')

    if args.verbose:
        logging.info("Formal species: {}".format(natural_sort(fs)))
        logging.info("Signal Complexes:")
        for cplx in natural_sort(signals):
            logging.info('   {} = {}'.format(cplx.name, cplx.kernel_string))
        logging.info("Fuel Complexes:")
        for cplx in natural_sort(fuels):
            logging.info('   {} = {}'.format(cplx.name, cplx.kernel_string))

    if dnafile:
        with open(dnafile, 'w') as dna:
            TestTubeIO(solution).write_dnafile(dna, signals = signals,
                                               crn = fcrn, ts = args.ts if args.ts else None)
        print("Wrote file: {}".format(dnafile))

    pilstring = TestTubeIO(solution).write_pil(fh = None,
                                               unit = args.concentration_units, 
                                               crn = fcrn, fs = fs,
                                               ts = args.ts if args.ts else None)
    if args.pilfile:
        with open(comppil, 'w') as pil:
            pil.write(pilstring)
        print("Wrote file: {}".format(comppil))
    else:
        print(pilstring)

    ####
    # Compilation is done now ... 
    # Lets go on with verification, enumeration, etc.
    ####

    if args.verify or args.enumerate:
        logging.info("")
        logging.info(colors.BOLD + "Enumerating reaction pathways..." + colors.ENDC)
        solution.enumerate_reactions(args, prefix = 'i', condensed = not args.enum_detailed)

        if not solution.reactions:
            raise SystemExit('No DSD reactions have been enumerated.')

        # Only for debugging.
        #pilstring = TestTubeIO(solution).write_pil(fh = None,
        #                                           unit = args.concentration_units, 
        #                                           crn = fcrn, fs = fs,
        #                                           ts = args.ts if args.ts else None)

        logging.info("")
        logging.info(colors.BOLD + "Replacing regular-expression complexes ..." + colors.ENDC)
        # History domains within constant and intermediate species will not get replaced.
        interpret = solution.interpret_species(fs.keys(), prune = True)

        pilstring = TestTubeIO(solution).write_pil(fh = None,
                                                   unit = args.concentration_units, 
                                                   crn = fcrn, fs = fs,
                                                   ts = args.ts if args.ts else None)
        if args.pilfile:
            with open(enumpil, 'w') as pil:
                pil.write(pilstring)
            print("Wrote file: {}".format(enumpil))

        # Return the implementation CRN. (= enumerated CRN)
        icrn = []
        for r in natural_sort(solution.reactions):
            logging.info("reaction {}".format(r.full_string()))
            rxn = Reaction(map(str, r.reactants), map(str, r.products), r.rate.constant, 0)
            icrn.append(rxn)

        print("")
        print("Enumerated system: {} species, {} reactions".format(len(solution.complexes), len(icrn)))
        print("  - {} signal species".format(
            len([c for c in solution.complexes if c.name in interpret.keys()])))
        print("  - {} fuel species".format(
            len([c for c in solution.complexes if c.name in map(str, fuels)])))
        print("  - {} intermediate species".format(
            len([c for c in solution.complexes if c.name not in 
                (interpret.keys() + map(str, fuels))])))
        print('Number of distinct strands in the system: {}'.format(len(solution.strands)))
        print('Length of all distinct strands in the system: {}'.format(sum(sum(
            map(lambda d: d.length, s)) for s in solution.strands.values())))
        print("")

        if args.modular:
            # TODO(SB): cross-check verification:
            # - enumeration detects crosstalk between modules and append it as
            #   the last iCRN which has no corresponding fCRN.
            logging.info("")
            logging.info(colors.BOLD + "Modular network enumeration ..." + colors.ENDC)

            seen_reactions = set()
            all_reactions = set(solution.reactions)

            module_crns = []
            for e, module in enumerate(modules):
                # first, replace history complexes with their interpretation!
                initials = map(str, module.complexes)
                for cplx in module.complexes:
                    # TODO quite inefficient loops
                    for k, v in interpret.items():
                        if (cplx.name in v) and k != cplx.name:
                            [newc] = solution.selected_complexes([k])
                            module.add_complex(newc, solution.get_complex_concentration(newc))
                            if module.has_complex(cplx):
                                module.rm_complex(cplx)

                module.enumerate_reactions(args, prefix = 'tmp', 
                        condensed = not args.enum_detailed)

                # after enumeration, make sure there are no new 'tmp' species present.
                for cplx in module.complexes:
                    assert cplx.name[:3] != 'tmp'

                # append the CRN
                logging.info("Module {}".format(e))
                mcrn = []
                for r in module.reactions:
                    assert r in all_reactions
                    seen_reactions.add(r)
                    logging.info("reaction {}".format(r.full_string()))
                    rxn = Reaction(map(str, r.reactants), map(str, r.products), r.rate.constant, 0)
                    mcrn.append(rxn)
                module_crns.append(mcrn)
                logging.info("")

            # last, identify crosstalk as the last implementation CRN 
            # (without formal correspondence)
            logging.info("Crosstalk")
            mcrn = [] # crosstalk
            for r in all_reactions :
                if r not in seen_reactions :
                    logging.info("reaction {}".format(r.full_string()))
                    rxn = Reaction(map(str, r.reactants), map(str, r.products), r.rate.constant, 0)
                    mcrn.append(rxn)

            # append the CRN
            if mcrn:
                module_crns.append(mcrn)

    # ~~~~~~~~~~~~~~~~~~~~~~~~~~
    # Verify equivalence of CRNs
    # ~~~~~~~~~~~~~~~~~~~~~~~~~~
    fcrm = map(lambda x: split_reversible_reactions([x]), fcrn)  # formal chemical reaction module
    fcrn = split_reversible_reactions(fcrn)

    if args.verify:
        logging.info("")
        logging.info(colors.BOLD + "Verification using: {}".format(args.verify) + colors.ENDC)

        vcrn = removeSpecies(icrn, map(str, fuels))
        if args.verbose:
            logging.info("Verification CRN:")
            map(lambda r: logging.info('    ' + r), genCRN(vcrn, reversible = True))
            logging.info("")

        if args.modular:
            icrns = map(lambda x: removeSpecies(x, map(str, fuels)), module_crns)
            if args.verbose:
                for e, m in enumerate(icrns):
                    if e < len(fcrm):
                        logging.info("CRN Module {}:".format(e + 1))
                        logging.info("--")
                        map(lambda r: logging.info('    ' + r), genCRN(fcrm[e], reversible = True))
                    else:
                        logging.info("CROSSTALK:")
                    logging.info("--")
                    map(lambda r: logging.info('    ' + r), genCRN(m, reversible = True))
                    logging.info("")

        for meth in args.verify:
            if interpret and args.verbose:
                if 'bisimulation' in meth:
                    logging.info("Partial interpretation for {}bisimulation:".format(
                        'modular-' if 'modular-' in meth else ''))
                    for impl, formal in sorted(interpret.items()):
                        logging.info("    {} => {}".format(impl, ', '.join(
                            [x for x in formal.elements()])))
                else :
                    logging.info("Formal species for pathway decomposition:")
                    logging.info("    {}".format(interpret.keys()))

            if 'modular-' in meth:
                if len(fcrm) > 1:
                    # NOTE: Temporary to fix a bug in testModules
                    import copy
                    backup = copy.deepcopy(interpret) if interpret else None
                    v, i = modular_bisimulation(fcrm, icrns, fs, interpret=backup, method=meth[8:],
                                                verbose=(args.verbose > 1), timeout=args.verify_timeout)
                    # NOTE: you can pass on the interpretation like this:
                    #if v: 
                    #    logging.warning('updating interpretation with modular-bisimulation results')
                    #    interpret = i
                else :
                    assert fcrn == fcrm[0]
                    v, i = verify(fcrn, vcrn, fs, interpret=interpret, method=meth[8:],
                              verbose=(args.verbose > 1), timeout=args.verify_timeout)
            else:
                v, i = verify(fcrn, vcrn, fs, interpret=interpret, method=meth,
                              verbose=(args.verbose > 1), timeout=args.verify_timeout)
                # NOTE: you can pass on the interpretation like this:
                #if v and i : interpret = i

            if v is True:
                print(" {}: CRNs are {} equivalent.".format(v, meth))
            elif v is False:
                print(" {}: CRNs are not {} equivalent.".format(v, meth))
            elif v is None:
                print(" {}: {} verification did not terminate within {} seconds.".format(
                        v, meth, args.verify_timeout))

            if i and args.verbose:
                if not v:
                    i = i[2 if 'modular-' in meth and len(fcrm) > 1 else 0]
                logging.info("Returned interpretation ['{}']:".format(meth))
                for impl, formal in sorted(i.items()):
                    logging.info("    {} => {}".format(
                        impl, ', '.join([x for x in formal.elements()])))
            print("")


    ## # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ## # Simulate CRNs in a TestTube
    ## # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ## if args.simulate:
    ##     logging.info("-----")
    ##     logging.info("Writing executable simulator scripts: {}_fCRN.py {}_iCRN.py".format(
    ##         args.output, args.output))

    ##     # Change CRN format from [[r], [p], [None]], if needed and add rate 1 to
    ##     # every reaction.
    ##     scrn = map(lambda rxn: rxn[:2] +
    ##                (rxn[2] if rxn[2] != [None] else [1]), fcrn)

    ##     # Simulate the formal CRN using crnsimulator
    ##     CRG = ReactionGraph(scrn)
    ##     fFile, _ = CRG.write_ODE_lib(
    ##         sorted(CRG.species), filename=args.output + '_fCRN')
    ##     if args.verbose:
    ##         logging.info('Wrote formal CRN simulator:'.format(fFile))
    ##         logging.info(' - execute with: python {}'.format(fFile))

    ##     # Simulate the interpretation CRN using crnsimulator
    ##     iFile, _ = solution.simulate_crn(
    ##         args.output + '_iCRN', unit=args.concentration_units)
    ##     if args.verbose:
    ##         logging.info('Wrote implementation CRN simulator:'.format(iFile))
    ##         logging.info(' - execute with: python {}'.format(iFile))


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        formatter_class = argparse.ArgumentDefaultsHelpFormatter,
        description = """Nuskell: Compile a formal CRN to a DSD system specification.""")
    parser = get_nuskell_args(parser)
    parser = get_peppercorn_args(parser)
    args = parser.parse_args()
    main(args)
