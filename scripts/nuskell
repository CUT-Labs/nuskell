#!/usr/bin/env python

import os
import sys
import signal
import argparse
import pkg_resources

from nuskell import translate, verify, printCRN
from nuskell.compiler import InvalidSchemeError

from nuskell.parser import parse_crn_string, split_reversible_reactions
from nuskell.objects import TestTube, TestTubeIO 
from nuskell.enumeration import TestTubePeppercornIO
from nuskell.verifier import removeSpecies

class TimeoutError(Exception):
  pass

def handler(signum, frame):
  raise TimeoutError('Time over')

def get_peppercorn_args(parser):
  """Selected arguments for the peppercorn interface. """
  parser.add_argument('--max-complex-size', default=100, type=int, dest='MAX_COMPLEX_SIZE', 
      metavar='<int>',
      help="Peppercorn: Maximum number of strands allowed in a complex" + \
          "(used to prevent polymerization)")
  parser.add_argument('--max-complex-count', default=1000, type=int, dest='MAX_COMPLEX_COUNT',
      metavar='<int>',
      help="Peppercorn: Maximum number of complexes that may be enumerated" + \
          "before the enumerator halts.")
  parser.add_argument('--max-reaction-count', default=10000, type=int, dest='MAX_REACTION_COUNT',
      metavar='<int>',
      help="Peppercorn: Maximum number of reactions that may be enumerated " + \
          "before the enumerator halts.")

  parser.add_argument('--reject-remote', action='store_true', dest='REJECT_REMOTE',
      help="Peppercorn: Discard remote toehold mediated 3-way and 4-way branch migration reactions.")
  parser.add_argument('--ignore-branch-3way', action='store_true',
      help="Peppercorn: Ignore 3-way branch migration events during enumeration.")
  parser.add_argument('--ignore-branch-4way', action='store_true',
      help="Peppercorn: Ignore 4-way branch migration events during enumeration.")

  # TODO: explain these options in more deatail!
  parser.add_argument('--release-cutoff-1-1', type=int, default=6, dest='RELEASE_CUTOFF_1_1',
      metavar='<int>',
      help="Peppercorn: Maximum number of bases that will be released spontaneously "+\
          "in a 1-1 `open` reaction" )
  parser.add_argument('--release-cutoff-1-n', type=int, default=6, dest='RELEASE_CUTOFF_1_N',
      metavar='<int>',
      help="Peppercorn: Maximum number of bases that will be released spontaneously " + \
          "in a 1-n `open` reaction.")
  parser.add_argument('--release-cutoff', type=int, default=None, dest='RELEASE_CUTOFF',
      metavar='<int>',
      help="Peppercorn: Maximum number of bases that will be released spontaneously " +\
          "in an `open` reaction, for either 1-1 or 1-n reactions (equivalent to setting " + \
          "--release-cutoff-1-1 and --release-cutoff-1-n to the same value)")

  parser.add_argument('--no-max-helix', action='store_true',
      help="Peppercorn: Don't apply 'max helix at a time' semantics to " +\
          "3-way branch migration reactions.")
  parser.add_argument('--legacy-unzip', action='store_true', dest='LEGACY_UNZIP',
      help="Peppercorn: Apply legacy 'UNZIP=True' behavior. Note: --legacy-unzip" + \
      "mode will have no effect, if max helix semantics are disabled (--no-max-helix)")

  # NOTE: Output formatting: this option is not directly passed on to peppercorn
  parser.add_argument('--enum-uncondensed', action='store_true',
      help="Peppercorn: Don't condense reactions into only resting complexes")

  # NOTE: The option --no-rates was removed, because peppercorn always computes
  # rates, but you may choose to ignore them for condensed reaction graphs. 
  # k-fast enables to prune the condensed network, leaving the default of 0 M/s, has
  # the same effect.

  parser.add_argument('--k-slow', default=0.0, type=float, metavar='<flt>',
      help="Unimolecular reactions slower than this rate will be discarded")

  parser.add_argument('--k-fast', default=0.0, type=float, metavar='<flt>',
      help="Unimolecular reactions slower than this rate will be marked as slow")

  return parser

def get_nuskell_args(parser) :
  """ A collection of arguments for Nuskell """

  # Options for the translation mode of Nuskell
  parser.add_argument("--ts", action = 'store', metavar='</path/to/file>',
      help="Specify path to the translation scheme")

  parser.add_argument("--readpil", action = 'store',
      help=argparse.SUPPRESS)
      #help="Read compiled CRN from pilfile. (As an alternative to --ts).")

  parser.add_argument("--pilfile", action = 'store_true',
      help="Print results in the *.pil file format.")

  parser.add_argument("--domfile", action = 'store_true',
      help="Print results in the *.dom file format.")

  parser.add_argument("--dnafile", action = 'store_true',
      help="Print results in the *.dna file format.")

  # Choose a verification method.
  parser.add_argument("--verify", nargs='+', default='', action = 'store', 
      metavar = '<str>', help="Specify verification methods: \
          (bisimulation, pathway, integrated, bisim-loop-search,\
          bisim-depth-first, bisim-whole-graph)") 

  parser.add_argument("--verify-timeout", type=int, default=30, metavar='<int>',
      help="Specify time [seconds] to wait for verification to complete.")

  parser.add_argument("--enumerate", action = 'store_true',
      help="Enumerate the implementation CRN.")

  parser.add_argument("--simulate", action = 'store_true',
      help=argparse.SUPPRESS)
      #help="Simulate the CRNs.")

  parser.add_argument("-o", "--output", default='domainlevel', action = 'store', metavar='<str>',
      help="Specify name of output file")

  parser.add_argument("-v", "--verbose", action='count', default=0,
      help="Print more output (-vv for extra debugging information)")

  return parser

def main() :
  """ The Nuskell compiler.  
  
  Commandline-parameters are collected in order to 
    - translate formal CRNs into domainlevel strand displacement systems.
    - verify the equivalence between formal CRN and enumerated implementation CRN.

  Output:
    - Domain-level DSD circuits printed into .pil .dom and/or .dna files
    - Verbose information during verification
    - Result of verification

  """
  parser = argparse.ArgumentParser(
      formatter_class=argparse.ArgumentDefaultsHelpFormatter)
  parser = get_nuskell_args(parser)
  parser = get_peppercorn_args(parser)
  args = parser.parse_args()

  args.UNZIP = not args.no_max_helix

  # Parse the input CRN 
  input_crn = sys.stdin.readlines()
  input_crn = "".join(input_crn)
  (fcrn, fs, cs) = parse_crn_string(input_crn) 
  fcrn = split_reversible_reactions(fcrn)

  # ~~~~~~~~~~~~~~~~~~~~~~~~
  # Prepare CRN and TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~
  if args.ts : # Translate CRN using a translation scheme
    print "\nTranslating..."
    pilfile = args.output + '.pil' if args.pilfile else None
    domfile = args.output + '.dom' if args.domfile else None
    dnafile = args.output + '.dna' if args.dnafile else None

    solution, constant_solution = translate(input_crn, args.ts, 
        pilfile = pilfile,
        domfile = domfile,
        dnafile = dnafile,
        verbose = (args.verbose > 1)) 
    
    if pilfile or domfile or dnafile :
      print "Wrote file(s):",
      if pilfile: print pilfile,
      if domfile: print domfile,
      if dnafile: print dnafile,
      print

  elif args.readpil : # Parse implementation species from a PIL file
    print "Parsing PIL file..."
    solution = TestTube()
    TestTubeIO(solution).load_pilfile(args.readpil)
  else :
    # NOTE: At some point Nuskell should choose translation schemes automatically.
    print "Please specify a translation scheme, see option --ts. For example:"
    schemedir = pkg_resources.resource_filename('nuskell', 'schemes')
    for s in os.listdir(schemedir) :
      print " --ts {}".format(s) 
    raise SystemExit

  if args.verbose :
    print "Complexes in Solution: "
    for cplx in solution.complexes:
      print ' ', cplx.name, map(str, cplx.sequence), cplx.structure

  #NOTE: At this point we have defined at least two kinds of species:
  # formal species = species that are present in the input CRN
  # fuel species = all non-formal species that have concentration > 0 nM
  # In many cases, fuel species have 'infinite' concentration at this point,
  # and the experimental concentrations are adjusted using simulations
  # later-on.

  fuels = map(str, solution.present_species(exclude=fs))
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Prepare enumerated CRN and TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  if args.verify or args.simulate or args.enumerate :
    print "\nEnumerating reaction pathways..."
    condensed = not args.enum_uncondensed
    solution.enumerate_reactions(args, condensed = condensed)

    enum_crn = []
    for r in solution.reactions:
      if args.verbose:
        print r, "[{} {} - {}]".format(r.rate, r.rateunits, r.rtype)
      rxn = [map(str,r.reactants),map(str,r.products)]
      enum_crn.append(rxn)

    print "\nReplacing regular-expression complexes ..."
    interpret = solution.interpret_species(fs, prune=True)
    # Do the same thing with remaining species? No need of the interpretation,
    # but it is important to prune the network if there are constant species
    # with history-domains...
    # tmp = solution.interpret_species(cs=)

    icrn = []
    # Implementation CRN is an enumerated CRN after regex-complexes have been
    # removed.
    for r in solution.reactions:
      if args.verbose:
        print r, "[{} {} - {}]".format(r.rate, r.rateunits, r.rtype)
      rxn = [map(str,r.reactants),map(str,r.products)]
      icrn.append(rxn)

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Verify equivalence of CRNs
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~
  if args.verify :
    print "\nVerification using:", args.verify

    vcrn = removeSpecies(icrn, fuels)
    if args.verbose :
      print "Verification CRN:"
      printCRN(vcrn, reversible = True)

    if interpret and args.verbose :
      print "Partial interpretation:"
      for impl, formal in sorted(interpret.items()) :
        print "  {} => {}".format(impl, ', '.join([x for x in formal.elements()]))

    for meth in args.verify :
      signal.signal(signal.SIGALRM, handler)
      signal.alarm(args.verify_timeout)
      try :
        v, i = verify(fcrn, vcrn, fs, interpret=interpret, method=meth,
            verbose=(args.verbose>1))

        if i and args.verbose :
          if not v : i = i[0]
          print "Returned interpretation ['{}']:".format(meth)
          for impl, formal in sorted(i.items()) :
            print "  {} => {}".format(impl, ', '.join([x for x in formal.elements()]))

        if v:
          print " {}: CRNs are {} equivalent.".format(v, meth)
        else:
          print " {}: CRNs are not {} equivalent.".format(v, meth)
      except TimeoutError:
        v = None
        print " {}: {} verification did not terminate within {} seconds.".format(v, 
            meth, args.verify_timeout)
      finally:
        signal.alarm(0)

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Simulate CRNs in a TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if args.simulate :
    print "\nWriting executable simulator scripts:", args.output+'_fCRN.py', args.output+'_iCRN.py'
    # Simulate the formal CRN using crnsimulator
    from crnsimulator import crn_to_ode, writeODElib

    # Add rate=1 to every reaction
    scrn = map(lambda x: x + [1], fcrn)
    V, M, J, R = crn_to_ode(scrn)
    fFile = writeODElib(V, M, jacobian = J, rdict = R, odename = args.output+'_fCRN')

    if args.verbose :
      print 'Wrote formal CRN simulator:', fFile
      print ' - execute with: python {}'.format(fFile)

    # Simulate the interpretation CRN using crnsimulator
    iFile = solution.simulate_crn(args.output + '_iCRN')
    if args.verbose :
      print 'Wrote implementation CRN simulator:', iFile
      print ' - execute with: python {}'.format(iFile)


if __name__ == '__main__':
  main()

