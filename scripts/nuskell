#!/usr/bin/env python

import sys
import signal
import argparse

from nuskell import translate, enumerateTT, verify, printCRN

from nuskell.parser import parse_crn_string, split_reversible_reactions
from nuskell.objects import TestTube, TestTubeIO
from nuskell.verifier import preprocess

# Replace with local routine!
from nuskell.include.peppercorn.enumerator import get_peppercorn_args

class TimeoutError(Exception):
  pass

def handler(signum, frame):
  raise TimeoutError('Time over')

def get_nuskell_args(parser) :
  """ A collection of arguments for Nuskell """

  # Options for the translation mode of Nuskell
  parser.add_argument("--ts", action = 'store',
      help="Specify path to the translation scheme")

  parser.add_argument("--readpil", action = 'store',
      help=argparse.SUPPRESS)
      #help="Read compiled CRN from pilfile. (As an alternative to --ts).")

  parser.add_argument("--pilfile", action = 'store_true',
      help="Print results in the *.pil file format.")

  parser.add_argument("--domfile", action = 'store_true',
      help="Print results in the *.dom file format.")

  parser.add_argument("--dnafile", action = 'store_true',
      help="Print results in the *.dna file format.")

  # Choose a verification method.
  parser.add_argument("--verify", nargs='+', default='', action = 'store',
      help="Specify verification methods: \
          (bisimulation, pathway, integrated, bisim-loop-search,\
          bisim-depth-first, bisim-whole-graph)") 

  parser.add_argument("--verify-timeout", type=int, default=30,
      help="Specify time [seconds] to wait for verification to complete.")

  parser.add_argument("--enumerate", action = 'store_true',
      help="Enumerate the implementation CRN.")

  parser.add_argument("--simulate", action = 'store_true',
      help=argparse.SUPPRESS)
      #help="Simulate the CRNs.")

  parser.add_argument("-o", "--output", default='domainlevel', action = 'store',
      help="Specify name of output file")

  return parser

def main() :
  """ The Nuskell compiler.  
  
  Commandline-parameters are collected in order to 
    - translate formal CRNs into domainlevel strand displacement systems.
    - verify the equivalence between formal CRN and enumerated implementation CRN.

  Output:
    - Domain-level DSD circuits printed into .pil .dom and/or .dna files
    - Verbose information during verification
    - Result of verification

  """
  parser = argparse.ArgumentParser(
      formatter_class=argparse.ArgumentDefaultsHelpFormatter)
  parser = get_nuskell_args(parser)
  parser = get_peppercorn_args(parser)
  args = parser.parse_args()

  # Parse the input CRN 
  input_crn = sys.stdin.readlines()
  input_crn = "".join(input_crn)
  (fcrn, fs, cs) = parse_crn_string(input_crn) 

  # ~~~~~~~~~~~~~~~~~~~~~~~~
  # Prepare CRN and TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~
  if args.ts : # Translate CRN using a translation scheme

    print "\nTranslating..."
    pilfile = args.output + '.pil' if args.pilfile else None
    domfile = args.output + '.dom' if args.domfile else None
    dnafile = args.output + '.dna' if args.dnafile else None

    solution, constant_solution = translate(input_crn, args.ts, 
        pilfile = pilfile,
        domfile = domfile,
        dnafile = dnafile,
        verbose = (args.verbose > 1)) 
    
    if pilfile or domfile or dnafile :
      print "Wrote file(s):",
      if pilfile: print pilfile,
      if domfile: print domfile,
      if dnafile: print dnafile,
      print

  elif args.readpil : # Parse implementation species from a PIL file
    print "Parsing PIL file..."
    solution = TestTube()
    raise NotImplementedError
    solution.load_pilfile(args.pilfile)
  else :
    raise NotImplementedError("Automated choice of translation scheme is not implemented")
    solution = None

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Prepare enumerated CRN and TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if args.verify or args.simulate or args.enumerate :
    print "\nEnumerating reaction pathways..."
    enum_solution, enum_crn = enumerateTT(solution, args)

    if args.verbose :
      print "Enumerated CRN:"
      printCRN(enum_crn, reversible = True)

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Verify equivalence of CRNs
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~
  if args.verify :
    print "\nVerification preprocessing..."
    fcrn = split_reversible_reactions(fcrn)

    if True:
      # Reduce the enumerated CRN and find an interpretation
      icrn, interpret = preprocess(fcrn, enum_crn, fs,
          solution, enum_solution, verbose=(args.verbose>1))
    else :
      # Reduce the enumerated CRN without finding an interpretation
      import nuskell.verifier.verifier
      cs = filter(lambda x: x not in fs, solution.complexes)
      icrn = nuskell.verifier.verifier.removeSpecies(enum_crn, cs)
      icrn = nuskell.verifier.verifier.removeDuplicates(icrn)
      interpret = None #dict()

    if args.verbose :
      print "Implementation CRN:"
      printCRN(icrn, reversible = True)

    print "\nVerification using:", args.verify
    if interpret and args.verbose :
      print "Partial interpretation:"
      for impl, formal in sorted(interpret.items()) :
        print "  {} => {}".format(impl, ', '.join([x for x in formal.elements()]))

    for meth in args.verify :
      signal.signal(signal.SIGALRM, handler)
      signal.alarm(args.verify_timeout)
      try :
        v, i = verify(fcrn, icrn, fs, interpret=interpret, method=meth,
            verbose=(args.verbose>1))

        if i and args.verbose :
          if not v : i = i[0]
          print "Returned interpretation:"
          for impl, formal in sorted(i.items()) :
            print "  {} => {}".format(impl, ', '.join([x for x in formal.elements()]))

        if v:
          print " {}: CRNs are {} equivalent.".format(v, meth)
        else:
          print " {}: CRNs are not {} equivalent.".format(v, meth)
      except TimeoutError:
        v = None
        print " {}: {} verification did not terminate within {} seconds.".format(v, 
            meth, args.verify_timeout)
      finally:
        signal.alarm(0)

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Simulate CRNs in a TestTube
  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if args.simulate :
    raise NotImplementedError

if __name__ == '__main__':
  main()

