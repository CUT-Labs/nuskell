#!/usr/bin/env python
#
#
# Copyright (c) 2009-2015 Caltech. All rights reserved.
# Written by Seung Woo Shin (seungwoo.theory@gmail.com)
#
#
# Verifier executable.
#

import sys, compiler, crn_parser, dom_parser, random, os, crn_bisimulation_equivalence, crn_pathway_equivalence, string, copy, enumerator.input as enumerator_in, enumerator.output as enumerator_out

def find(l, key):
    for i in range(len(l)):
        if l[i] == key:
            return i
    return None

def rotate(complex):
    def hardcopyList(l):
        if type(l) != list:
            return l
        return map(hardcopyList, l)

    complex = hardcopyList(complex)

    if "+" not in complex[0]:
        return complex        
    else:
        p = find(complex[0], "+")
        dom = complex[0][p + 1:] + ["+"] + complex[0][:p]

        # change parentheses appropriately
        dpr = complex[1]
        stack = []
        for i in range(p):
            if dpr[i] == "(": stack.append(i)
            elif dpr[i] == ")": stack.pop()
        for i in stack:
            dpr[i] = ")"
        stack = []
        for i in reversed(range(p + 1, len(dpr))):
            if dpr[i] == ")": stack.append(i)
            elif dpr[i] == "(": stack.pop()
        for i in stack:
            dpr[i] = "("
        
        dpr = dpr[p + 1:] + ["+"] + dpr[:p]
        return [dom, dpr]

def patternMatch(x, y):
    if "+" in x[0]:
        if "+" not in y[0]:
            return False
        px = find(x[0], "+")
        py = find(y[0], "+")
        return patternMatch([x[0][:px], x[1][:px]],
                            [y[0][:py], y[1][:py]]) and \
               patternMatch([x[0][px + 1:], x[1][px + 1:]],
                            [y[0][py + 1:], y[1][py + 1:]])

    if len(x[0]) == 0:
        if len(y[0]) > 0:
            return False
        else:
            return True

    if x[0][0] != "?":
        if len(y[0]) == 0 or x[0][0] != y[0][0] or x[1][0] != y[1][0]:
            return False
        else:
            return patternMatch([x[0][1:], x[1][1:]],
                                [y[0][1:], y[1][1:]])
    else:
        for i in range(len(y) + 1):
            if patternMatch([x[0][1:], x[1][1:]],
                            [y[0][i:], y[1][i:]]):
                return True
        return False

def removeFuels(crn, fuel):
    crn = [[filter(lambda s: s not in fuel, rxn[0]),
            filter(lambda s: s not in fuel, rxn[1])]
           for rxn in crn]
    return crn

def remove_duplicates(l):
    r = []
    if len(l) == 0: return []
    l.sort()
    while len(l) > 1:
        if l[0] != l[1]:
            r.append(l[0])
        l = l[1:]
    r.append(l[0])
    return r

def test(crnfile, domfile, method, verbose = True, condense = True):
    # Parse the crn
    (old_crn, fs, cs_waste) = crn_parser.parse_file(crnfile)       # fs is the set of formal species
    t = old_crn
    old_crn = []
    for [x, r, p] in t:
        old_crn.append([r,p])
        if x == "reversible":
            old_crn.append([p,r])

    # Parse the dom
    tfile = "".join(random.sample(string.letters + string.digits, 8)) + "._tmp"
    dom = dom_parser.parse(domfile)

    # Generate an input file for state enumerator
    F = open(tfile, "w")
    if len(dom) == 2:   # there is sequence information
        complexes = dom[1]
        for i in dom[0]:
            print >> F, "domain", i[0], ":", i[1]
    else:
        complexes = dom[0]

    strand_n = 0
    out_strands = {}
    out_complexes = []

    for i in complexes:
        c = [i[0],"",""]
        s = ""
        i[1].append("+")
        for j in i[1]:
            if j == "?": continue
            if type(j) == list:
                if len(j) == 2:
                    j = j[0] + j[1]
                else:
                    j = j[0]
                s += " " + j
            elif j == "+":
                if s not in out_strands.keys():
                    strand_n += 1
                    sname = "strand"+str(strand_n)
                    out_strands[s] = sname
                else:
                    sname = out_strands[s]
                s = ""
                c[1] += " "+sname
        i[1] = i[1][:-1]
        for j in i[2]:
            if j == "?": continue
            if j == "+": j = " + "
            c[2] += j
        out_complexes.append(c)

    for s in out_strands.keys():
        sname = out_strands[s]
        print >> F, "strand", sname, ":", s

    for [c0,c1,c2] in out_complexes:
        print >> F, "complex", c0, ":"
        print >> F, c1
        print >> F, c2
        print >> F
    F.close()

    # constant species
    cs = map(lambda x: x[0], complexes)
    cs = filter(lambda x: x not in fs, cs)

    #
    # call state enumerator
    #
    enumerator = enumerator_in.input_enum(tfile)
    enumerator.MAX_COMPLEX_COUNT = 10000
    enumerator.MAX_REACTION_COUNT = 50000
    enumerator.MAX_COMPLEX_SIZE = 100
    enumerator.REJECT_REMOTE = True
    enumerator.enumerate()
    enumerator_out.output_crn(enumerator,tfile, output_condensed = condense)
    F = open(tfile, "r")
    new_crn = []
    for line in F:
        line = line.split("->")
        line[0] = line[0].split("+")
        line[1] = line[1].split("+")
        line[0] = map(lambda x: x.strip(), line[0])
        line[1] = map(lambda x: x.strip(), line[1])
        line[0] = sorted(line[0])
        line[1] = sorted(line[1])
        new_crn.append(line)
    F.close()
    # delete the temporary file
    filelist = [ f for f in os.listdir(".") if f.endswith("._tmp") ]
    for f in filelist:
        os.remove(f)

    # convert the output from state enumerator to cmpdna format
    slow_complexes = []
    for z in enumerator.resting_states:
        name = str(z)
        for y in z.complexes:
            y1 = []
            for x in y.strands:
                y1.append("+")
                for w in x.domains:
                    w = str(w)
                    if w[-1] == "*":
                        y1.append([w[:-1], "*"])
                    else:
                        y1.append([w])
            if len(y1)>0: y1 = y1[1:]
            y = [name, y1, list(y.dot_paren_string())]
            slow_complexes.append(y)

    #
    # perform wildcard pattern matching
    #

    wildcardMatch = {}

    collapsed = set()
    for x in complexes:
        for y in slow_complexes:
            if x[0] == y[0]: continue
            original = x[1:]
            target = y[1:]
            pos = 0
            startpos = 0
            while startpos < len(target[0]):
                if pos - startpos == len(original[0]):
                    for i in range(startpos, pos):
                        if original[0][i-startpos] == "?":
                            del target[0][i]
                            del target[1][i]
                            collapsed.add(y[0])
                    while startpos < len(target[0]) and "+" != target[0][startpos]:
                        startpos += 1
                    startpos += 1
                    pos = startpos
                elif pos == len(target[0]):
                    while startpos < len(target[0]) and "+" != target[0][startpos]:
                        startpos += 1
                    startpos += 1
                    pos = startpos
                elif target[0][pos] == original[0][pos - startpos] or (original[0][pos-startpos] == "?" and target[1][pos] == "."):
                    pos += 1
                else:
                    while startpos < len(target[0]) and "+" != target[0][startpos]:
                        startpos += 1
                    startpos += 1
                    pos = startpos
    for i in range(len(slow_complexes)):
        for j in range(len(slow_complexes)):
            if i == j: continue
            x = slow_complexes[i][1:]
            y = slow_complexes[j][1:]
            p = rotate(x)
            while True:
                if p == y:
                    if slow_complexes[i][0] in collapsed and slow_complexes[j][0] not in collapsed:
                        wildcardMatch[slow_complexes[i][0]] = slow_complexes[j][0]
                        #print slow_complexes[i], "to", slow_complexes[j]
                if p == x:
                    break
                p = rotate(p)

    # the following routine renames species that are pattern-matched.
    # OK. this is very ad-hoc and hopefully will be
    # re-written at one point.
    inter = {} # initial interpretation for bisimulation
    rm = set()
    for x in fs: inter[x] = [x]
    fsp = fs[:] # formal species list for pathway decomposition
    for i in range(len(new_crn)):
        [reactants, products] = new_crn[i]
        def get_name(x):
            if x in wildcardMatch.keys() and wildcardMatch[x] in fs:
                y = wildcardMatch[x]
                if y in fs: rm.add(y)
                wildcardMatch[y+"_"+x] = y # this update is for later
                x = y + "_" + x
                if x not in fsp:
                    fsp.append(x)
                if x not in inter.keys():
                    inter[x] = [y]
            return x
        reactants = map(get_name, reactants)
        products = map(get_name, products)
        new_crn[i] = [reactants, products]

    # preprocess fuel
    new_crn = removeFuels(new_crn, cs)
    new_crn = sorted(map(lambda x: [sorted(x[0]), sorted(x[1])], new_crn))
    new_crn = remove_duplicates(new_crn)

    # removing initial signals that are unnecessary
    fsp = set(fsp)
    for x in rm:
        if x in inter.keys(): del inter[x]
        if x in fsp: fsp.remove(x)
    norm = set(fsp)-rm
    flag = None
    while flag != norm:
        flag = set(list(norm))
        for [r,p] in new_crn:
            if set(r).intersection(norm) == set(r):
                norm = norm.union(set(p))
    new_crn = filter(lambda x: set(x[0]).intersection(norm) == set(x[0]), new_crn)

    # fs = formal species; cs = fuels or constant species
    if method == "--bisimulation":
        return crn_bisimulation_equivalence.test((old_crn, fs), (new_crn, fs), verbose)#, inter)
    elif method == "--pathway":
        return crn_pathway_equivalence.test((old_crn, fs), (new_crn, fsp), inter, verbose, False)
    elif method == "--integrated":
        return crn_pathway_equivalence.test((old_crn, fs), (new_crn, fsp), inter, verbose, True)



if __name__ == "__main__":
    # The name of the program
    program_name = "verify"

    # Help message
    if "--help" in sys.argv:
        print "Usage: " + program_name + " TSFILE CRNFILE [OPTION]"
        print "Compile CRNFILE to DNA molecules using the translation scheme",
        print "from TSFILE and verify the result."
        print
        print "  --pathway      Use the compositional hybrid notion [default]."
        print "  --bisimulation Use the bisimulation equivalence notion."
        print "  --integrated   Use the integrated hybrid notion."
        print "  --help         Output this help."
        print
        print "Report bugs to <seungwoo.theory@gmail.com>."
        exit()

    # Did I get a sufficient number of arguments?
    if len(sys.argv) < 3: # expects at least two arguments
        print program_name + ": missing operand after `" + program_name + "'"
        print program_name + ": try `" + program_name + " --help' for more information."
        exit()

    # Get the arguments.
    ts_file = sys.argv[1]
    crn_file = sys.argv[2]
    if len(sys.argv) < 4: method = "--pathway" 
    else: method = sys.argv[3]

    # Add the correct extensions if necessary.
    if len(ts_file) < 3 or ts_file[-3:] != ".ts": ts_file += ".ts"
    if len(crn_file) < 4 or crn_file[-4:] != ".crn": crn_file += ".crn"

    compiler.compile(ts_file, crn_file)
    v = test(crn_file, crn_file[:-4] + ".dom", method)

    if v:
        print "verify: compilation was correct."
    else:
        print "verify: compilation was incorrect."
